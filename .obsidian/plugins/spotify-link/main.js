/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SpotifyLinkPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/api.ts
var import_obsidian = require("obsidian");

// src/utils.ts
function prepareData(data) {
  return Object.keys(data).map(
    (key) => encodeURIComponent(key) + "=" + encodeURIComponent(data[key])
  ).join("&");
}
function millisToMinutesAndSeconds(millis) {
  const minutes = Math.floor(millis / 6e4);
  const seconds = parseInt((millis % 6e4 / 1e3).toFixed(0));
  if (minutes === 0) {
    return (seconds < 10 ? "0" : "") + seconds + "s";
  }
  return minutes + "m:" + (seconds < 10 ? "0" : "") + seconds + "s";
}

// src/output.ts
function processCurrentlyPlayingTrackInput(data) {
  let message = "";
  if (data && data.is_playing) {
    message = `['**${data.item.name}**' by ***${data.item.artists.map((a) => a.name).join(", ")}*** **${millisToMinutesAndSeconds(
      data.progress_ms
    )}** (${(data.progress_ms / parseInt(data.item.duration_ms) * 100).toFixed(0)}%)](${data.item.external_urls.spotify})`;
  } else {
    message = "No song is playing.";
  }
  return message;
}
function processCurrentlyPlayingTrack(data, template = `'{{ song_name }}' by {{ artists }} from {{ album }} released in {{ album_release }}
{{ timestamp }}`) {
  var _a, _b, _c, _d;
  let message = "";
  if (data && data.is_playing) {
    message = template.replace(/{{ song_name }}|{{song_name}}/g, data.item.name).replace(
      /{{ song_link }}|{{song_link}}/g,
      data.item.external_urls.spotify
    ).replace(
      /{{ artists }}|{{artist}}/g,
      data.item.artists.map((a) => a.name).join(", ")
    ).replace(
      /{{ album_release }}|{{album_release}}/g,
      data.item.album.release_date
    ).replace(
      /{{ album_cover_large }}|{{album_cover_large}}/g,
      `![${data.item.album.name}](${data.item.album.images[0].url})`
    ).replace(
      /{{ album_cover_medium }}|{{album_cover_medium}}/g,
      `![${data.item.album.name}](${(_a = data.item.album.images[1]) == null ? void 0 : _a.url})`
    ).replace(
      /{{ album_cover_small }}|{{album_cover_small}}/g,
      `![${data.item.album.name}](${(_b = data.item.album.images[2]) == null ? void 0 : _b.url})`
    ).replace(
      /{{ album_cover_link_large }}|{{album_cover_link_large}}/g,
      data.item.album.images[0].url
    ).replace(
      /{{ album_cover_link_medium }}|{{album_cover_link_medium}}/g,
      (_c = data.item.album.images[1]) == null ? void 0 : _c.url
    ).replace(
      /{{ album_cover_link_small }}|{{album_cover_link_small}}/g,
      (_d = data.item.album.images[2]) == null ? void 0 : _d.url
    ).replace(
      /{{ album_link }}|{{album_link}}/g,
      data.item.album.external_urls.spotify
    ).replace(/{{ album }}|{{album}}/g, data.item.album.name).replace(
      /{{ timestamp }}|{{timestamp}}/g,
      `${new Date().toDateString()} - ${new Date().toLocaleTimeString()}`
    );
  } else {
    message = "No song is playing.";
  }
  return message;
}

// src/api.ts
var SPOTIFY_API_BASE_ADDRESS = "https://api.spotify.com/v1";
var REDIRECT_URI = "obsidian://spotify-auth/";
function generateLoginUrl(clientId, state, scope, redirectUri) {
  const q = `response_type=code&client_id=${clientId}&scope=${scope}&redirect_uri=${redirectUri}&state=${state}`;
  return `https://accounts.spotify.com/authorize?${q}`;
}
async function handleCallback(params, clientId, clientSecret, state) {
  if (params.state !== state)
    throw new Error("Invalid state");
  if (params.error)
    throw new Error(params.error);
  if (!params.code)
    throw new Error("Missing Code");
  const response = await requestAccessToken(
    clientId,
    clientSecret,
    params.code,
    REDIRECT_URI
  );
  setAccessToken(response.access_token);
  setRefreshToken(response.refresh_token);
  setExpiration(response.expires_in);
  return true;
}
async function requestAccessToken(clientId, clientSecret, code, redirect_uri) {
  const data = {
    code,
    redirect_uri,
    grant_type: "authorization_code"
  };
  return await (0, import_obsidian.requestUrl)({
    url: "https://accounts.spotify.com/api/token",
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      Authorization: `Basic ${btoa(clientId + ":" + clientSecret)}`
    },
    body: prepareData(data)
  }).then((res) => res.json);
}
function setAccessToken(accessToken) {
  window.localStorage.setItem("access_token", accessToken);
}
function setRefreshToken(refreshToken) {
  window.localStorage.setItem("refresh_token", refreshToken);
}
function setExpiration(expiresIn) {
  window.localStorage.setItem(
    "expires_in",
    (new Date().getTime() + expiresIn * 1e3).toString()
  );
}
async function requestRefreshToken(clientId, clientSecret) {
  const refreshToken = getRefreshToken();
  const data = {
    client_id: clientId,
    refresh_token: refreshToken,
    grant_type: "refresh_token"
  };
  const response = await (0, import_obsidian.requestUrl)({
    url: "https://accounts.spotify.com/api/token",
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
      Authorization: `Basic ${btoa(clientId + ":" + clientSecret)}`
    },
    body: prepareData(data)
  }).then((res) => res.json);
  setAccessToken(response.access_token);
  setRefreshToken(response.refresh_token || refreshToken);
  setExpiration(response.expires_in);
  return response.access_token;
}
async function getCurrentlyPlayingTrack(clientId, clientSecret) {
  var _a;
  const token = await getAccessToken(clientId, clientSecret);
  try {
    const response = await (0, import_obsidian.requestUrl)({
      url: `${SPOTIFY_API_BASE_ADDRESS}/me/player/currently-playing`,
      method: "GET",
      headers: {
        Authorization: `Bearer ${token}`
      }
    });
    const { json } = response;
    if (response.status !== 200) {
      throw new Error(((_a = json == null ? void 0 : json.error) == null ? void 0 : _a.message) || response.status);
    }
    const currentlyPlayingTrack = json;
    if (!currentlyPlayingTrack)
      throw new Error("Unable to get the currently playing track.");
    return currentlyPlayingTrack;
  } catch (e) {
    throw new Error("Unable to get the currently playing track.");
  }
}
async function getCurrentlyPlayingTrackAsString(clientId, clientSecret) {
  const track = await getCurrentlyPlayingTrack(clientId, clientSecret);
  return processCurrentlyPlayingTrackInput(track);
}
async function getMe(clientId, clientSecret) {
  var _a;
  const token = await getAccessToken(clientId, clientSecret);
  const response = await (0, import_obsidian.requestUrl)({
    url: `${SPOTIFY_API_BASE_ADDRESS}/me`,
    method: "GET",
    headers: {
      Authorization: `Bearer ${token}`
    }
  });
  const { json } = response;
  if (response.status !== 200) {
    throw new Error(((_a = json == null ? void 0 : json.error) == null ? void 0 : _a.message) || response.status);
  }
  return json;
}
async function getSpotifyUrl(clientId, clientSecret) {
  const me = await getMe(clientId, clientSecret);
  return me.external_urls.spotify;
}
function getExpiration() {
  const expiration = window.localStorage.getItem("expires_in");
  if (!expiration)
    throw new Error(
      "Something went wrong, please manually log back to spotify."
    );
  return parseInt(expiration);
}
async function getAccessToken(clientId, clientSecret) {
  const token = window.localStorage.getItem("access_token");
  if (!token)
    throw new Error("You are not connected to Spotify.");
  if (new Date().getTime() <= getExpiration())
    return token;
  return await requestRefreshToken(clientId, clientSecret);
}
function getRefreshToken() {
  const token = window.localStorage.getItem("refresh_token");
  if (!token)
    throw new Error("You are not connected to Spotify.");
  return token;
}

// src/settingsTab.ts
var import_obsidian2 = require("obsidian");
var DEFAULT_SETTINGS = {
  spotifyClientId: "",
  spotifyClientSecret: "",
  spotifyScopes: "user-read-currently-playing",
  spotifyState: "it-can-be-anything",
  templates: []
};
var SettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const div = containerEl.createDiv();
    div.createEl("p", {
      text: "Follow the link below to get your Client Id and Client Secret, you need a spotify account to get access."
    });
    div.createEl("a", {
      href: "https://developer.spotify.com/dashboard/",
      text: "Spotify Developer"
    });
    div.createEl("ol").createEl("li", { text: "Create an App" }).createEl("li", { text: "Click Settings" }).createEl("li", { text: "Copy the Client Id and Secret" }).createEl("li", {
      text: "Set the Redirect URI to : obsidian://spotify-auth/"
    }).createEl("li", {
      text: "Select the Spotify icon located in Obsidian's left sidebar to connect."
    });
    div.createEl("p", {
      text: "NOTICE: The id and secret will be stored unencrypted on your local device. If you sync your data to a public source, the id and secret will be shown as-is."
    });
    new import_obsidian2.Setting(containerEl).setName("Spotify Client ID").setDesc("Client ID (Keep this secured)").addText((text) => {
      text.setPlaceholder("Enter your client id").setValue(this.plugin.settings.spotifyClientId).onChange(async (value) => {
        this.plugin.settings.spotifyClientId = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.setAttribute("type", "password");
    });
    new import_obsidian2.Setting(containerEl).setName("Spotify Client Secret").setDesc("Client Secret (Keep this secured)").addText((text) => {
      text.setPlaceholder("Enter your client Secret").setValue(this.plugin.settings.spotifyClientSecret).onChange(async (value) => {
        this.plugin.settings.spotifyClientSecret = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.setAttribute("type", "password");
    });
    new import_obsidian2.Setting(containerEl).setName("Spotify State").setDesc("State").addText((text) => {
      text.setPlaceholder("Enter your State").setValue(this.plugin.settings.spotifyState).onChange(async (value) => {
        this.plugin.settings.spotifyState = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.setAttribute("type", "password");
    });
    new import_obsidian2.Setting(containerEl).setName("Spotify Redirect URI").setDesc("Redirect URI (Read Only)").addText((text) => {
      text.setValue("obsidian://spotify-auth/").setDisabled(true);
    });
    containerEl.createEl("hr");
    containerEl.createEl("h5", { text: "Templates" });
    const divDoc = containerEl.createDiv();
    divDoc.createEl("a", {
      href: "https://studiowebux.github.io/obsidian-plugins-docs/docs/spotify-link/custom-template",
      text: "Custom Template Documentation"
    });
    divDoc.createEl("p", { text: "Available variables:" });
    divDoc.createEl("ul").createEl("li", { text: "{{ album }}" }).createEl("li", { text: "{{ album_release }}" }).createEl("li", { text: "{{ album_cover_large }}" }).createEl("li", { text: "{{ album_cover_medium }}" }).createEl("li", { text: "{{ album_cover_small }}" }).createEl("li", { text: "{{ album_cover_link_large }}" }).createEl("li", { text: "{{ album_cover_link_medium }}" }).createEl("li", { text: "{{ album_cover_link_small }}" }).createEl("li", { text: "{{ album_link }}" }).createEl("li", { text: "{{ artists }}" }).createEl("li", { text: "{{ song_name }}" }).createEl("li", { text: "{{ song_link }}" }).createEl("li", { text: "{{ timestamp }}" });
    new import_obsidian2.Setting(containerEl).setName("Template").setDesc(
      "Define a custom template to print the currently playing song"
    ).addTextArea(
      (text) => text.setPlaceholder(
        "Example: '{{ song_name }}' by {{ artists }} from {{ album }} released in {{ album_release }}\n{{ timestamp }}"
      ).setValue(this.plugin.settings.templates[0]).onChange(async (value) => {
        this.plugin.settings.templates[0] = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("hr");
    containerEl.createEl("h5", { text: "Spotify Integration (Advanced)" });
    new import_obsidian2.Setting(containerEl).setName("Spotify Scopes").setDesc(
      "Scopes (comma-delimited list, you should update this only if you know what you are doing."
    ).addText(
      (text) => text.setPlaceholder("Enter your Scopes").setValue(this.plugin.settings.spotifyScopes).onChange(async (value) => {
        this.plugin.settings.spotifyScopes = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("hr");
    containerEl.createEl("a", {
      href: "https://studiowebux.github.io/obsidian-plugins-docs/docs/category/plugin-spotify-link",
      text: "Official Plugin Documentation"
    });
  }
};

// src/ui.ts
var import_obsidian3 = require("obsidian");
async function handleEditor(editor, clientId, clientSecret) {
  try {
    const track = await getCurrentlyPlayingTrackAsString(
      clientId,
      clientSecret
    );
    editor.replaceSelection(
      `> ${track}
> ${new Date().toDateString()} - ${new Date().toLocaleTimeString()}

`
    );
  } catch (e) {
    new import_obsidian3.Notice(e.message);
  }
}
async function handleTemplateEditor(editor, template, clientId, clientSecret) {
  try {
    const track = await getCurrentlyPlayingTrack(clientId, clientSecret);
    editor.replaceSelection(
      `${processCurrentlyPlayingTrack(track, template)}

`
    );
  } catch (e) {
    new import_obsidian3.Notice(e.message);
  }
}

// src/events.ts
async function onAutoLogin(clientId, clientSecret) {
  const profile = await getMe(clientId, clientSecret);
  return profile ? { success: true, spotifyUrl: profile.external_urls.spotify } : { success: false, spotifyUrl: "" };
}
function onLogin(clientId, state, scope) {
  window.open(generateLoginUrl(clientId, state, scope, REDIRECT_URI));
}

// src/main.ts
var SpotifyLinkPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    // States
    this.spotifyConnected = false;
    this.spotifyUrl = "";
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingsTab(this.app, this));
    (0, import_obsidian4.addIcon)(
      "spotify",
      '<path fill="currentColor" d="M 52.021502,2.019 C 24.520376,2.019 2.019,24.520376 2.019,52.021502 2.019,79.517624 24.520376,102.019 52.021502,102.019 79.517624,102.019 102.019,79.517624 102.019,52.021502 102.019,24.520376 79.767861,2.019 52.021502,2.019 Z m 22.996847,72.248636 c -0.995946,1.496422 -2.74761,2.001902 -4.254041,1.005956 -11.756168,-7.256894 -26.50518,-8.758321 -44.006806,-4.759522 -1.741655,0.510485 -3.243081,-0.740703 -3.743557,-2.247134 -0.50548,-1.751665 0.745709,-3.243081 2.25214,-3.748562 18.993043,-4.254041 35.498724,-2.497372 48.496071,5.50523 1.751664,0.745709 2.001902,2.742606 1.256193,4.244032 z m 6.005706,-13.74806 c -1.256194,1.746659 -3.503328,2.497372 -5.259997,1.246183 -13.497823,-8.237826 -33.992293,-10.750212 -49.742255,-5.745458 -1.991893,0.50548 -4.254042,-0.500475 -4.749512,-2.492368 -0.505481,-2.011911 0.500475,-4.26405 2.497372,-4.764526 18.247335,-5.49522 40.753716,-2.742605 56.248436,6.761424 1.501426,0.745708 2.25214,3.24308 1.005956,4.994745 z m 0.49547,-14.008308 C 65.519325,37.017248 38.768912,36.016297 23.514421,40.775819 a 4.6944597,4.6944597 0 0 1 -5.745459,-3.002853 4.689455,4.689455 0 0 1 2.997848,-5.760472 c 17.751865,-5.249988 47.004655,-4.254042 65.507232,6.761423 2.247135,1.246184 2.997848,4.249037 1.74666,6.496172 -1.251189,1.751664 -4.249037,2.492367 -6.501177,1.241179 z" style="stroke-width:5.00475" />'
    );
    this.addRibbonIcon("spotify", "Connect Spotify", async () => {
      onLogin(
        this.settings.spotifyClientId,
        this.settings.spotifyState,
        this.settings.spotifyScopes
      );
    });
    this.statusBar = this.addStatusBarItem();
    this.registerInterval(
      window.setInterval(() => this.updateStatusBar(), 3e4)
    );
    this.registerObsidianProtocolHandler(
      "spotify-auth",
      async (params) => {
        try {
          this.spotifyConnected = await handleCallback(
            params,
            this.settings.spotifyClientId,
            this.settings.spotifyClientSecret,
            this.settings.spotifyState
          );
          new import_obsidian4.Notice(
            "Spotify Link Plugin: Connected to Spotify !",
            3e3
          );
          this.spotifyUrl = await getSpotifyUrl(
            this.settings.spotifyClientId,
            this.settings.spotifyClientSecret
          );
        } catch (e) {
          new import_obsidian4.Notice(
            "[ERROR] Spotify Link Plugin: " + e.message,
            3e3
          );
          this.spotifyConnected = false;
        } finally {
          this.updateStatusBar();
        }
      }
    );
    this.addCommand({
      id: "append-currently-playing-track-using-template",
      name: "Append Spotify currently playing track using template",
      editorCallback: async (editor) => {
        await handleTemplateEditor(
          editor,
          this.settings.templates[0],
          this.settings.spotifyClientId,
          this.settings.spotifyClientSecret
        );
      }
    });
    this.addCommand({
      id: "append-currently-playing-track",
      name: "Append Spotify currently playing track with timestamp",
      editorCallback: async (editor) => {
        await handleEditor(
          editor,
          this.settings.spotifyClientId,
          this.settings.spotifyClientSecret
        );
      }
    });
    this.addCommand({
      id: "refresh-session",
      name: "Refresh session",
      callback: async () => {
        try {
          await requestRefreshToken(
            this.settings.spotifyClientId,
            this.settings.spotifyClientSecret
          );
          new import_obsidian4.Notice(`Spotify Link Plugin: Access Refreshed`);
        } catch (e) {
          new import_obsidian4.Notice(`[ERROR] Spotify Link Plugin: ${e.message}`);
        }
      }
    });
    try {
      const info = await onAutoLogin(
        this.settings.spotifyClientId,
        this.settings.spotifyClientSecret
      );
      this.spotifyConnected = info.success;
      this.spotifyUrl = info.spotifyUrl;
    } catch (e) {
      new import_obsidian4.Notice(`[ERROR] Spotify Link Plugin: ${e.message}`);
      return false;
    } finally {
      this.updateStatusBar();
    }
  }
  onunload() {
  }
  updateStatusBar() {
    this.statusBar.setText(
      `Spotify ${!this.spotifyConnected ? "not" : ""} Connected`
    );
    this.statusBar.onClickEvent((ev) => {
      window.open(this.spotifyUrl);
    });
  }
};
